package com.akvelon.server.dao.impl;

import com.akvelon.server.dao.api.Dao;
import com.akvelon.server.domain.Entity;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

/**
 * Implementation of the DAO interface. The class implements all CRUD operations for domain objects.
 * Child classes must implement three abstract methods from this class.
 * @param <K> type of primary key (ID).
 * @param <V> type of domain object.
 */
@Repository
public abstract class SuperDao<K, V extends Entity<K>> implements Dao<K, V> {

    @Autowired
    protected JdbcTemplate jdbcTemplate;

    private static final String SQL_SELECT_ALL = "SELECT * FROM %s";
    private static final String SQL_GET_BY = "SELECT * FROM %s WHERE %s = ?";
    private static final String SQL_DELETE_BY_ID = "DELETE FROM %s WHERE %s = ?";

    @Override
    public List<V> getAll() {
        String sql = String.format(SQL_SELECT_ALL, getClassObject().getClass().getSimpleName().toLowerCase());

        return jdbcTemplate.query(sql, getRowMapper());
    }

    @Override
    public K create(V value) {
        KeyHolder keyHolder = new GeneratedKeyHolder();

        jdbcTemplate.update((con) -> createInsertStatement(con, value), keyHolder);

        setId(value, keyHolder);

        return value.getId();
    }

    @Override
    public V read(K key) {
        return readBy(getClassObject().getClass().getSimpleName() + "ID", key);
    }

    @Override
    public void update(V value) {
        jdbcTemplate.update((con) -> createUpdateStatement(con, value));
    }

    @Override
    public void delete(K key) {
        String sql = String.format(SQL_DELETE_BY_ID, getClassObject().getClass().getSimpleName().toLowerCase(), getClassObject().getClass().getSimpleName() + "ID");

        jdbcTemplate.update(sql, key);
    }

    @Override
    public <T> V readBy(String fieldName, T value) {
        List<V> result = readAllBy(fieldName, value);

        if (result == null || result.size() == 0) {
            return null;
        }

        return result.get(0);
    }

    @Override
    public <T> List<V> readAllBy(String fieldName, T value) {
        String sql = String.format(SQL_GET_BY, getClassObject().getClass().getSimpleName().toLowerCase(), fieldName);

        return jdbcTemplate.query(sql, new Object[]{value}, getRowMapper());
    }

    /**
     * Return domain object of type V.
     */
    protected abstract V getClassObject();

    /**
     * Set id which auto generated by the database.
     * @param value domain object.
     * @param keyHolder keyholder with generated keys.
     */
    protected abstract void setId(V value, KeyHolder keyHolder);

    /**
     * Return RowMapper object for domain object.
     */
    protected abstract RowMapper<V> getRowMapper();

    /**
     * Create a PreparedStatement with an INSERT request for the domain object.
     * @param connection sql database connection
     * @param value domain object.
     * @return PreparedStatement with an INSERT request for the domain object.
     * @throws SQLException
     */
    protected abstract PreparedStatement createInsertStatement(Connection connection, V value) throws SQLException;

    /**
     * Create a PreparedStatement with an UPDATE request for the domain object.
     * @param connection sql database connection
     * @param value domain object.
     * @return PreparedStatement with an UPDATE request for the domain object.
     * @throws SQLException
     */
    protected abstract PreparedStatement createUpdateStatement(Connection connection, V value) throws SQLException;
}
